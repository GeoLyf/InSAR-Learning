##-------------------------------------------------- README --------------------------------------------------##
## Author：Liyifu
## Date：2026/01/26
## Method：ISCE2 → MintPy
## MintPy的配置文件模板，参考github官网的smallbaselineApp.cfg，网址如下所示：              
## https://github.com/insarlab/MintPy/blob/main/src/mintpy/defaults/smallbaselineApp.cfg          
## https://github.com/insarlab/MintPy/blob/main/src/mintpy/defaults/smallbaselineApp_auto.cfg
## Following paper：https://doi.org/10.1016/j.cageo.2019.104331
## Notes：山东科技大学开源了一款名为ESIS的软件，将MintPy（阉割版，很多参数默认了）移植到了Windows系统下且具有GUI，网址如下所示：
## https://github.com/ZGHHGZ/ESIS/releases
##------------------------------------------------------------------------------------------------------------##



##-------------------------------------------------- 预处理：ISEC2-stackSentinel.py --------------------------------------------------##
## 对于ISCE2 → MintPy，需要使用interferogram Workflow，最终会生成16个run_files，本次实验的参数设置如下所示：
## stackSentinel.py -s ../SLC/ -d ../DEM/demLat_N31_N33_Lon_E119_E121.dem.wgs84 -a ../AuxDir/ -o ../Orbit/ -b '31.96 32.36 119.56 120.01' -n '2 3' -m 20221203 -c 5 -z 4 -r 20 -f 0.4 -useGPU
## 处理完成后会在当前目录下生成14个文件夹，若内存不足，只保留baselines、merged、reference、secondarys这四个文件夹即可
##------------------------------------------------------------------------------------------------------------------------------------##



##-------------------------------------------------- Usage：steps processing (start/end/dostep) --------------------------------------------------##
## smallbaselineApp.py -g可在当前目录下生成默认的配置文件，再按需修改参数即可
## smallbaselineApp.py一共有以下18个步骤：
## ['load_data', 'modify_network', 'reference_point', 'quick_overview', 'correct_unwrap_error']
## ['invert_network', 'correct_LOD', 'correct_SET', 'correct_ionosphere', 'correct_troposphere']
## ['deramp', 'correct_topography', 'residual_RMS', 'reference_date', 'velocity', 'geocode']
## ['google_earth', 'hdfeos5']
## 使用--start或--dostep命令必须满足一个前提条件：之前已经运行过该程序，并且至少成功完成了当前步骤的前一步
## --start STEP   #start processing at the named step (default: load_data).
## --end STEP     #end processing at the named step (default: hdfeos5)
## --dostep STEP  #run processing at the named step only（最常用）
## 建议不要一次性跑完18个步骤，因为MintPy高度依赖于前置步骤的结果，需要根据每一步的结果不断调整某些参数
## eg. smallbaselineApp.py Yangzhong.cfg --dostep load_data
##------------------------------------------------------------------------------------------------------------------------------------------------##



##-------------------------------------------------- 0.计算资源配置 --------------------------------------------------##
## 这部分与InSAR处理无关，主要是配置smallbaselineApp.py的最大内存和并行处理数量，所以保持默认即可
## 如果处理比较大型的项目，可适当调整maxMemory
mintpy.compute.maxMemory = 16    #[float > 0.0], auto for 4, max memory to allocate in GB
mintpy.compute.cluster   = auto  #[local / slurm / pbs / lsf / none], auto for none, cluster type
mintpy.compute.numWorker = auto  #[int > 1 / all / num%], auto for 4 (local) or 40 (slurm / pbs / lsf), num of workers
mintpy.compute.config    = auto  #[none / slurm / pbs / lsf ], auto for none (same as cluster), config name
##--------------------------------------------------------------------------------------------------------------------##



##-------------------------------------------------- 1.数据导入 --------------------------------------------------##
## load_data.py -H可以查看官方的数据导入示例，如下所示：
##----------Default file path of ISCE/topsStack products
## mintpy.load.processor       = isce
## mintpy.load.metaFile        = ../reference/IW*.xml
## mintpy.load.baselineDir     = ../baselines

## mintpy.load.unwFile         = ../merged/interferograms/*/filt*.unw
## mintpy.load.corFile         = ../merged/interferograms/*/filt*.cor
## mintpy.load.connCompFile    = ../merged/interferograms/*/filt*.unw.conncomp
## mintpy.load.intFile         = None

## mintpy.load.ionUnwFile      = ../ion/*/ion_cal/filt.ion
## mintpy.load.ionCorFile      = ../ion/*/ion_cal/raw_no_projection.cor
## mintpy.load.ionConnCompFile = None

## mintpy.load.demFile         = ../merged/geom_reference/hgt.rdr
## mintpy.load.lookupYFile     = ../merged/geom_reference/lat.rdr
## mintpy.load.lookupXFile     = ../merged/geom_reference/lon.rdr
## mintpy.load.incAngleFile    = ../merged/geom_reference/los.rdr
## mintpy.load.azAngleFile     = ../merged/geom_reference/los.rdr
## mintpy.load.shadowMaskFile  = ../merged/geom_reference/shadowMask.rdr
## mintpy.load.waterMaskFile   = ../merged/geom_reference/waterMask.rdr
## mintpy.load.bperpFile       = None
##------------------------------------------------------
## autoPath - 在mintpy.defaults.auto_path.AUTO_PATH_*中预定义的自动路径模式
## 压缩选项，用于节省ifgramStack.h5文件的磁盘空间：
## none - 节省0%磁盘空间，处理速度最快【默认】
## lzf  - 节省约57%磁盘空间，处理速度相对较慢
## gzip - 节省约62%磁盘空间，处理速度非常缓慢【不推荐】

##------------------------- 基础设置 -------------------------##
mintpy.load.processor       = isce  #[isce, aria, hyp3, gmtsar, snap, gamma, roipac, nisar], auto for isce
mintpy.load.autoPath        = no    #[yes / no], auto for no, use pre-defined auto path
mintpy.load.updateMode      = yes   #[yes / no], auto for yes, skip re-loading if HDF5 files are complete
mintpy.load.compression     = none  #[gzip / lzf / none / default], auto for default (none/lzf for stack/geometry).

##------------------------- for ISCE2 only -------------------------##
## 只有使用ISCE2进行处理时需要配置此栏，使用其他软件时保持默认即可
mintpy.load.metaFile        = ../reference/IW*.xml  #[path of common metadata file for the stack], i.e.: ./reference/IW1.xml, ./referenceShelve/data.dat
mintpy.load.baselineDir     = ../baselines          #[path of the baseline dir], i.e.: ./baselines

##------------------------- 干涉图堆栈 -------------------------##
## 滤波后的相位解缠、相干性、连通分量、干涉图、强度图文件
## 用ISCE2处理时，不会生成强度图文件，保持默认即可
mintpy.load.unwFile         = ../merged/interferograms/*/filt*.unw           #[path pattern of unwrapped interferogram files]
mintpy.load.corFile         = ../merged/interferograms/*/filt*.cor           #[path pattern of spatial coherence files]
mintpy.load.connCompFile    = ../merged/interferograms/*/filt*.unw.conncomp  #[path pattern of connected components files], optional but recommended
mintpy.load.intFile         = auto                                           #[path pattern of wrapped interferogram files], optional
mintpy.load.magFile         = auto                                           #[path pattern of interferogram magnitude files], optional

##------------------------- 电离层堆栈 -------------------------##
## 一般忽略电离层延迟的影响，ISCE2也未进行电离层延迟校正，保持默认即可
mintpy.load.ionUnwFile      = auto  #[path pattern of unwrapped interferogram files]
mintpy.load.ionCorFile      = auto  #[path pattern of spatial coherence files]
mintpy.load.ionConnCompFile = auto  #[path pattern of connected components files], optional but recommended

##------------------------- 偏移量追踪堆栈 -------------------------##
## ISCE2的interferogram工作流不涉及偏移量追踪，保持默认即可
mintpy.load.azOffFile       = auto  #[path pattern of azimuth offset file]
mintpy.load.rgOffFile       = auto  #[path pattern of range offset file]
mintpy.load.azOffStdFile    = auto  #[path pattern of azimuth offset variance file], optional but recommended
mintpy.load.rgOffStdFile    = auto  #[path pattern of range offset variance file], optional but recommended
mintpy.load.offSnrFile      = auto  #[path pattern of offset signal-to-noise ratio file], optional

##------------------------- 地理信息文件 -------------------------##
## DEM、纬度、经度、入射角、方位角、阴影掩膜、水体掩膜、垂直基线文件
## 用ISCE2处理时，不会生成水体掩膜、垂直基线文件，保持默认即可
## MintPy会自动从DEM文件中提取水体掩膜，从.xml文件中计算垂直基线
mintpy.load.demFile         = ../merged/geom_reference/hgt.rdr         #[path of DEM file]
mintpy.load.lookupYFile     = ../merged/geom_reference/lat.rdr         #[path of latitude / row / y coordinate file], not required for geocoded data
mintpy.load.lookupXFile     = ../merged/geom_reference/lon.rdr         #[path of longitude / column / x coordinate file], not required for geocoded data
mintpy.load.incAngleFile    = ../merged/geom_reference/los.rdr         #[path of incidence angle file], optional but recommended
mintpy.load.azAngleFile     = ../merged/geom_reference/los.rdr         #[path of azimuth angle file], optional
mintpy.load.shadowMaskFile  = ../merged/geom_reference/shadowMask.rdr  #[path of shadow mask file], optional but recommended
mintpy.load.waterMaskFile   = auto                                     #[path of water mask file], optional but recommended
mintpy.load.bperpFile       = auto                                     #[path pattern of 2D perpendicular baseline file], optional

##------------------------- 研究区裁剪 -------------------------##
## 有两种裁剪方式：基于雷达坐标系（像素的行与列）、基于地理坐标系（经纬度），建议只设置lalo选项
## 如果同时指定了这两种坐标，则优先使用lalo（地理坐标）选项，除非同时满足以下两个条件：
## a)没有上一栏中的lookup file; b)数据集是雷达坐标系下的
mintpy.subset.yx            = no                         #[y0:y1,x0:x1 / no], auto for no
mintpy.subset.lalo          = 31.96:32.36,119.56:120.01  #[S:N,W:E / no], auto for no

##------------------------- 多视处理 -------------------------##
## 谨慎使用mean / median方法，它们可以平滑噪声以提高信噪比
## 但也可能平滑解缠误差，破坏整数2π关系，而这种关系被用于解缠误差校正
## 如果确实想要提高信噪比，请考虑以更多视数重新生成干涉图堆栈
## 在ISCE2的stackSentinel.py中已经进行了10:2的多视处理，因此在MintPy中无需进行多视，保持默认即可
mintpy.multilook.method     = auto  #[nearest, mean, median], auto for nearest - lines/rows skipping approach
mintpy.multilook.ystep      = auto  #[int >= 1], auto for 1 - no multilooking
mintpy.multilook.xstep      = auto  #[int >= 1], auto for 1 - no multilooking
##----------------------------------------------------------------------------------------------------------------##



##-------------------------------------------------- 2.干涉网络调整 --------------------------------------------------##
## MintPy调整干涉网络有两个步骤：1)基于时空基线阈值；2)基于相干性/有效相干比阈值
## step2只能二选一，选择其中一种方法调整为yes，另一种方法保持默认即可
## 基于相干性的方法适用于大多数常规InSAR处理，基于有效相干比的方法适用于地表覆盖不均匀的研究区域

##------------------------- 1)时空基线阈值设置 -------------------------##
mintpy.network.tempBaseMax     = 60    #[1-inf, no], auto for no, max temporal baseline in days
mintpy.network.perpBaseMax     = 150   #[1-inf, no], auto for no, max perpendicular spatial baseline in meter
mintpy.network.connNumMax      = 3     #[1-inf, no], auto for no, max number of neighbors for each acquisition
## 以下为日期范围筛选，可以先不设置，跑完一遍后看看结果，剔除掉相干性很差的影像或干涉对
mintpy.network.startDate       = auto  #[20090101 / no], auto for no
mintpy.network.endDate         = auto  #[20110101 / no], auto for no
mintpy.network.excludeDate     = auto  #[20080520,20090817 / no], auto for no
mintpy.network.excludeDate12   = auto  #[20080520_20090817 / no], auto for no
mintpy.network.excludeIfgIndex = auto  #[1:5,25 / no], auto for no, list of ifg index (start from 0)
## 以下这个很重要，可以通过创建一个date12_list.txt文件，手动调整干涉对组成
## 文件内容可能如下（还没试过）：20220101_20220125, 20220101_20220206……
mintpy.network.referenceFile   = auto  #[date12_list.txt / ifgramStack.h5 / no], auto for no

##------------------------- 2) a.相干性阈值设置 -------------------------##
## 该算法基于输入的掩膜（可指定感兴趣区域），利用空间相干性计算每个干涉图的平均相干性
## 然后以平均相干性的倒数为权重，构建一个最小生成树网络（前提是设置了keepMinSpanTree = yes）
## 接着，它会排除满足以下两个条件的干涉图：
## a)平均相干性 < 最小相干性阈值; b)不在最小生成树网络内
mintpy.network.coherenceBased  = yes  #[yes / no], auto for no, exclude interferograms with coherence < minCoherence
mintpy.network.minCoherence    = 0.8  #[0.0-1.0], auto for 0.7

##------------------------- 2) b.有效相干比阈值设置 -------------------------##
## 该算法计算每个干涉图中，高于某个空间相干性阈值的区域所占的比例（即面积比）
## 这个阈值是根据输入掩膜区域内干涉图的空间相干性情况来定义的
## 然后以该面积比的倒数为权重，构建一个最小生成树网络（前提是设置了keepMinSpanTree）
## 接着，它会排除满足以下两个条件的干涉图：
## a)面积比 < 最小面积比阈值; b)不在最小生成树网络中。
mintpy.network.areaRatioBased  = auto  #[yes / no], auto for no, exclude interferograms with area ratio < minAreaRatio
mintpy.network.minAreaRatio    = auto  #[0.0-1.0], auto for 0.75

##------------------------- 2) 方法a与b的公共参数设置 -------------------------##
mintpy.network.keepMinSpanTree = yes                        #[yes / no], auto for yes, keep interferograms in Min Span Tree network
mintpy.network.maskFile        = auto                       #[file name, no], auto for waterMask.h5 or no [if no waterMask.h5 found]
mintpy.network.aoiYX           = no                         #[y0:y1,x0:x1 / no], auto for no, area of interest for coherence calculation
mintpy.network.aoiLALO         = 31.96:32.36,119.56:120.01  #[S:N,W:E / no], auto for no - use the whole area
##--------------------------------------------------------------------------------------------------------------------##



##-------------------------------------------------- 3.参考点选取 --------------------------------------------------##
## InSAR测出的是相对形变，MintPy将所有干涉图参考至空间中的一个公共点
## auto - 随机选择一个相干性高于最小相干性阈值（minCoherence）的像素
## 然而，强烈建议基于研究区域的先验知识进行手动指定，选择时应遵循以下原则：
## 1)位于高相干性区域，以最小化失相干带来的影响
## 2)不受强大气湍流影响，避开出现电离层条纹的区域（不太理解）
## 3)靠近研究区域且海拔高度与之相似，以最小化大气延迟垂直分层分量的影响
mintpy.reference.yx            = auto  #[257,151 / auto]
mintpy.reference.lalo          = auto  #[31.8,130.8 / auto]
mintpy.reference.maskFile      = auto  #[filename / no], auto for maskConnComp.h5
mintpy.reference.coherenceFile = auto  #[filename], auto for avgSpatialCoh.h5
mintpy.reference.minCoherence  = 0.9   #[0.0-1.0], auto for 0.85, minimum coherence for auto method
##------------------------------------------------------------------------------------------------------------------##



##-------------------------------------------------- 快速预览 --------------------------------------------------##
## 该步无需配置参数，直接使用即可，预览内容包括：
## 1)可能的地表形变，使用传统InSAR Stacking方法估算出的形变速率
## 2)相位解缠误差的分布，通过统计具有非零闭合相位整数模糊度的干涉图三元组的数量来评估
##--------------------------------------------------------------------------------------------------------------##



##-------------------------------------------------- 4.相位解缠误差校正 --------------------------------------------------##
## 该步依赖于step 1中导入的connCompFile文件，目前只有SNAPHU这一解缠算法能提供连通分量文件
## 因此若想实现此步，在ISCE2处理时不能把参数设置为-u icu
## 支持的校正方法：
## 1)phase_closure          - 适用于冗余度高的干涉图网络，即ISCE2处理时-c参数较大的情况
## 2)bridging               - 适用于被狭窄的失相干特征（例如河流、狭窄水体）分隔的区域
## 3)bridging+phase_closure - 推荐使用，当桥接法校正后仍残留少量误差时尤其有效
## connCompMinArea          - 如果数据分辨率较低（多视较大），可以适当调小
mintpy.unwrapError.method          = bridging+phase_closure  #[bridging / phase_closure / bridging+phase_closure / no], auto for no
mintpy.unwrapError.waterMaskFile   = auto                    #[waterMask.h5 / no], auto for waterMask.h5 or no [if not found]
mintpy.unwrapError.connCompMinArea = 2000                    #[1-inf], auto for 2.5e3, discard regions smaller than the min size in pixels

##------------------------- phase_closure参数设置 -------------------------##
## numSample - 为加速基于L1范数正则化的最小二乘反演，本步骤采用了一种基于区域的策略
## 具体而言，程序并非为每个像素单独反演其整周模糊度，而是会生成一个公共连通分量掩膜
## 对于此掩膜中的每一个公共连通分量，程序会随机选择numSample个像素进行反演计算
## 然后将这些样本反演结果的中值应用于该公共连通分量内的所有像素
## 如果研究区域地物不均一，可适当增加
mintpy.unwrapError.numSample       = 150  #[int>1], auto for 100, number of samples to invert for common conn. comp.

##------------------------- bridging参数设置 -------------------------##
## ramp - 在桥接校正开始前，可基于图像中面积最大的可靠区域估计一个相位斜坡（趋势面）
##        并将此斜坡从整个干涉图的相位中移除，随后再估算不同可靠区域之间的相位差并进行桥接校正
##        在校正完成后，之前移除的相位斜坡会被重新加回到干涉图中
mintpy.unwrapError.ramp            = quadratic  #[linear / quadratic], auto for no; recommend linear for L-band data
mintpy.unwrapError.bridgePtsRadius = 50         #[1-inf], auto for 50, half size of the window around end points
##------------------------------------------------------------------------------------------------------------------------##



##-------------------------------------------------- 5.形变时间序列反演 --------------------------------------------------##
## 使用加权最小二乘估计，将干涉图网络反演为时间序列
## 最小二乘反演的权重选项：
## 1)var - 使用协方差矩阵的逆作为权重【推荐】
## 2)fim - 使用费希尔信息矩阵作为权重
## 3)coh - 使用相干性作为权重
## 4)no  - 均匀权重，不加权【快速】
## SBAS(Berardino et al., 2002) = minNormVelocity (yes) + weightFunc (no)
mintpy.networkInversion.weightFunc      = var   #[var / fim / coh / no], auto for var
mintpy.networkInversion.waterMaskFile   = auto  #[filename / no], auto for waterMask.h5 or no [if not found]
mintpy.networkInversion.minNormVelocity = yes   #[yes / no], auto for yes, min-norm deformation velocity / phase

## 反演前对每个干涉图解缠相位的掩膜选项（weightFunc = no时推荐使用）：
## 1)coherence(相干性)                               - 掩膜掉空间相干性低于maskThreshold阈值的像素
## 2)connectComponent(连通分量)                      - 掩膜掉连通分量值为False/0 的像素（即未成功解缠或不可靠的区域）
## 3)no                                              - 不进行任何掩膜【推荐】
## 4)range/azimuthOffsetStd(距离向/方位向偏移标准差) - 掩膜掉偏移量标准差大于maskThreshold 的像素【做offset时使用此项】
mintpy.networkInversion.maskDataset   = no    #[coherence / connectComponent / rangeOffsetStd / azimuthOffsetStd / no], auto for no
mintpy.networkInversion.maskThreshold = auto  #[0-inf], auto for 0.4
mintpy.networkInversion.minRedundancy = auto  #[1-inf], auto for 1.0, min num_ifgram for every SAR acquisition

## 计算时间相干性，并将其作为可靠性指标来生成掩膜
mintpy.networkInversion.minTempCoh  = 0.75  #[0.0-1.0], auto for 0.7, min temporal coherence for mask
mintpy.networkInversion.minNumPixel = 100   #[int > 1], auto for 100, min number of pixels in mask above
mintpy.networkInversion.shadowMask  = yes   #[yes / no], auto for yes [if shadowMask is in geometry file] or no.
##------------------------------------------------------------------------------------------------------------------------##



##-------------------------------------------------- 6.固体潮改正 --------------------------------------------------##
## 需要预先安装PySolid，详见github官网：https://github.com/insarlab/PySolid
## 安装方法可参考这个链接：https://mp.weixin.qq.com/s/3zuKXLRt7NYNGsXYAhU6ag
mintpy.solidEarthTides = yes  #[yes / no], auto for no
##------------------------------------------------------------------------------------------------------------------##



##-------------------------------------------------- 7.电离层延迟改正 --------------------------------------------------##
## 对于C波段（λ = 5.6mm）的Sentinel-1数据，电离层延迟可忽略，因此保持默认即可
mintpy.ionosphericDelay.method        = auto  #[split_spectrum / no], auto for no
mintpy.ionosphericDelay.excludeDate   = auto  #[20080520,20090817 / no], auto for no
mintpy.ionosphericDelay.excludeDate12 = auto  #[20080520_20090817 / no], auto for no
##----------------------------------------------------------------------------------------------------------------------##



##-------------------------------------------------- 8.对流层延迟改正 --------------------------------------------------##
## 对流层延迟分为垂直分层分量与湍流分量，可选择以下方法校正对流层延迟：
## 1)height_correlation - 校正对流层延迟的垂直分层分量，研究区域为山区时效果较好
## 2)pyaps              - 使用全球天气模型数据校正对流层延迟，有以下三种产品可供选择——
## a.ERA5   - 来自欧洲中期天气预报中心(ECMWF)的ERA5再分析数据【推荐使用，默认开启】
## b.MERRA  - 来自美国宇航局(NASA)的MERRA-2再分析数据
## c.NARR   - 来自美国国家海洋和大气管理局(NOAA)的NARR再分析数据【推荐用于北美地区】
## 3)gacos              - 使用基于迭代对流层分解模型的GACOS服务产品
mintpy.troposphericDelay.method = pyaps  #[pyaps / height_correlation / gacos / no], auto for pyaps

##------------------------- pyaps参数设置 -------------------------##
## 需要预先安装PyAPS并且需要配置ERA5，详见github官网：https://github.com/insarlab/PyAPS
## 安装方法和ERA5的配置方法可参考这个链接：https://mp.weixin.qq.com/s/3zuKXLRt7NYNGsXYAhU6ag
## PyAPS注意事项：
## 1)全球天气模型数据延迟
## 对于最新的SAR数据，可能会缺少对应的全球天气模型数据，校正将仅应用于有可用GAM数据的日期，其他日期会被跳过
## 2)WEATHER_DIR环境变量
## 如果定义一个名为WEATHER_DIR的环境变量，并将其值设置为一个目录的路径，那么MintPy将会把下载的GAM文件保存到该指定目录中
## MintPy程序在下载新的GAM文件之前，会先在该目录中查找是否已存在所需的文件
## 当处理不同但时间覆盖有重叠的数据集时，可以避免重复下载相同的数据，以提高处理效率
mintpy.troposphericDelay.weatherModel = ERA5  #[ERA5 / MERRA / NARR], auto for ERA5
mintpy.troposphericDelay.weatherDir   = auto  #[path2directory], auto for WEATHER_DIR or "./"

##------------------------- height_correlation参数设置 -------------------------##
## Extra multilooking is applied to estimate the empirical phase/elevation ratio ONLY.
## For an dataset with 5 by 15 looks, looks=8 will generate phase with (5*8) by (15*8) looks
## to estimate the empirical parameter; then apply the correction to original phase (with 5 by 15 looks),
## if the phase/elevation correlation is larger than minCorrelation.
## 由于mintpy.troposphericDelay.method = pyaps，此处保持默认即可
mintpy.troposphericDelay.polyOrder      = auto  #[1 / 2 / 3], auto for 1
mintpy.troposphericDelay.looks          = auto  #[1-inf], auto for 8, extra multilooking num
mintpy.troposphericDelay.minCorrelation = auto  #[0.0-1.0], auto for 0

##------------------------- gacos参数设置 -------------------------##
## 在下方设置包含已下载的 *.ztd 文件的目录路径，此处保持默认即可
mintpy.troposphericDelay.gacosDir = auto # [path2directory], auto for "./GACOS"



##-------------------------------------------------- 9.相位斜坡去除 --------------------------------------------------##
## 相位斜坡是一种系统性的误差，主要来源于轨道误差
## 推荐用于局部形变信号，例如火山形变、滑坡和地面沉降等
## 不推荐用于长波形变信号，例如同震、震后和震间形变
mintpy.deramp          = quadratic       #[no / linear（线性）/ quadratic（二次）], auto for no 
mintpy.deramp.maskFile = maskTempCoh.h5  #[filename / no], auto for maskTempCoh.h5
##--------------------------------------------------------------------------------------------------------------------##



##-------------------------------------------------- 10.地形残差去除 --------------------------------------------------##
## 地形残余误差主要来源于DEM误差
## stepDate - 如果研究区在某个时间段出现了较大的形变，例如地震，则需要指定发生的日期
## pixelwiseGeometry - 使用逐个像素的几何信息，为了提高精度可以使用，不过会增加处理时间和内存占用
mintpy.topographicResidual                   = yes  #[yes / no], auto for yes
mintpy.topographicResidual.polyOrder         = 2    #[1-inf], auto for 2, 用于拟合的多项式阶数
mintpy.topographicResidual.phaseVelocity     = no   #[yes / no], auto for no - 研究区域的大气效应严重时可调整为yes
mintpy.topographicResidual.stepDate          = no   #[20080529,20190704T1733 / no], auto for no
mintpy.topographicResidual.excludeDate       = no   #[20070321 / txtFile / no], auto for exclude_date.txt
mintpy.topographicResidual.pixelwiseGeometry = yes  #[yes / no], auto for yes
##---------------------------------------------------------------------------------------------------------------------##



##-------------------------------------------------- 11-1.基于残差均方根的噪声估计 --------------------------------------------------##
## 计算每个干涉图的残差相位时间序列的均方根(RMS)
## 残差 = 观测相位 - 已建模的相位，理想条件下残差应该只包含随机噪声
## 为了避免残留轨道误差或残余大气延迟造成干扰，会再移除一次相位斜坡，参数设置与step 9同理
## 将RMS > 阈值（cutoff） × 中值绝对偏差 的日期视为异常日期并写入exclude_date.txt，不参与后续的形变速率建模
## 若追求更高精度的话，可适当调低cutoff，以进一步减轻随机噪声的干扰
## Calculate the Root Mean Square (RMS) of residual phase time-series for each acquisition
## reference: Yunjun et al. (2019, section 4.9 and 5.4)
## To get rid of long spatial wavelength component, a ramp is removed for each acquisition
## Set optimal reference date to date with min RMS
## Set exclude dates (outliers) to dates with RMS > cutoff * median RMS (Median Absolute Deviation)
mintpy.residualRMS.maskFile = auto       #[file name / no], auto for maskTempCoh.h5, mask for ramp estimation
mintpy.residualRMS.deramp   = quadratic  #[quadratic / linear / no], auto for quadratic
mintpy.residualRMS.cutoff   = 2.5        #[0.0-inf], auto for 3

##-------------------------------------------------- 11-2.参考日期选取 --------------------------------------------------------------##
## 将上一步计算得到的RMS最小的日期设置为参考日期，以它为基准反演其他日期的形变速率，这样可使随机噪声的影响降至最低
## no - 默认第一个日期为参考日期【不推荐】
mintpy.reference.date = auto  #[reference_date.txt / 20090214 / no], auto for reference_date.txt
##-----------------------------------------------------------------------------------------------------------------------------------##



##-------------------------------------------------- 12.形变速率建模 --------------------------------------------------##
##------------------------- 日期范围筛选 -------------------------##
mintpy.timeFunc.startDate   = auto  #[20070101 / no], auto for no
mintpy.timeFunc.endDate     = auto  #[20101230 / no], auto for no
mintpy.timeFunc.excludeDate = auto  #[exclude_date.txt / 20080520,20090817 / no], auto for exclude_date.txt

##------------------------- 形变速率模型拟合 -------------------------##
## 尝试使用一个函数描述形变速率的变化，大多数情况下优先考虑线性模型，有以下五类函数模型：
## polynomial（多项式函数）- 由整数阶数定义，1代表线性，2代表二次，以此类推，用于描述长期形变趋势
## periodic（周期函数）    - 由以“年”为单位的周期列表定义，1代表年周期，0.5代表半年周期，以此类推，用于描述周期性形变
## step（阶跃函数）        - 通过指定stepDate定义，用于描述某一天的跳变（比如发生了地震）
## exp（指数函数）         - 由一个发生时间后跟一个以“天”为单位的特征时间整数来定义，用于描述快速变化后趋于稳定的过程，如滑坡后
## log（对数函数）         - 由一个发生时间后跟一个以“天”为单位的特征时间整数来定义，用于描述缓慢启动后加速的过程，如火山喷发前
## Multiple exp and log functions can be overlaied on top of each other, achieved via e.g.:（这里不太理解，保留原文）
## 20110311,60,120          - two functions sharing the same onset time OR
## 20110311,60;20170908,120 - separated by ";"
mintpy.timeFunc.polynomial = 1     #[int >= 0], auto for 1, degree of the polynomial function
mintpy.timeFunc.periodic   = auto  #[1,0.5 / list_of_float / no], auto for no, periods in decimal years
mintpy.timeFunc.stepDate   = auto  #[20110311,20170908 / 20120928T1733 / no], auto for no, step function(s)
mintpy.timeFunc.exp        = auto  #[20110311,60 / 20110311,60,120 / 20110311,60;20170908,120 / no], auto for no
mintpy.timeFunc.log        = auto  #[20110311,60 / 20110311,60,120 / 20110311,60;20170908,120 / no], auto for no

##------------------------- 精度评定 -------------------------##
## 不确定性量化，给形变速率标明一个误差范围，例如-30.2 ± 1.5 mm/yr，有以下三种方法：
## 1)residue（残差法）     - 假设时间上呈正态分布，从拟合残差传播误差【默认，给出的误差范围最小，结果会比较好看】
## 2)covariance（协方差法）- 从时间序列（协）方差矩阵传播误差【需要额外提供timeSeriesCovFile】
## 3)bootstrap（自助法）   - 独立且有放回地重采样【最稳健，给出的误差范围最大，但也最耗时】
mintpy.timeFunc.uncertaintyQuantification = residue  #[residue, covariance, bootstrap], auto for residue
mintpy.timeFunc.timeSeriesCovFile         = auto     #[filename / no], auto for no, time series covariance file
mintpy.timeFunc.bootstrapCount            = auto     #[int>1], auto for 400, number of iterations for bootstrapping
##---------------------------------------------------------------------------------------------------------------------##



##-------------------------------------------------- 13-1.地理编码 -----------------------------------------------------------##
## 地理编码，仅适用于输入数据集为雷达坐标系的情况
## 常用的以米为单位的分辨率及其在赤道对应的以度为单位的近似值：
## meter： 100,         90,          60,          50,          40,          30,          20,          10
## degree：0.000925926, 0.000833334, 0.000555556, 0.000462963, 0.000370370, 0.000277778, 0.000185185, 0.000092593
## eg. 0.000462963,0.000462963 = 50 x 50
mintpy.geocode              = yes                        #[yes / no], auto for yes
mintpy.geocode.SNWE         = 31.96,32.36,119.56,120.01  #[-1.2,0.5,-92,-91 / none ], auto for none, output extent in degree
mintpy.geocode.laloStep     = 0.000462963,0.000462963    #[-0.000555556,0.000555556 / None], auto for None, output resolution in degree
mintpy.geocode.interpMethod = nearest                    #[nearest], auto for nearest, interpolation method
mintpy.geocode.fillValue    = np.nan                     #[np.nan, 0, ...], auto for np.nan, fill value for outliers.

##-------------------------------------------------- 13-2.另存为kmz文件 -------------------------------------------------------##
## 可在Google Earth中初步查看可视化结果，推荐使用
mintpy.save.kmz             = yes  #[yes / no], auto for yes, save geocoded velocity to Google Earth KMZ file

##-------------------------------------------------- 13-3.另存为HDF-EOS5文件 --------------------------------------------------##
## 一般用不上，保持默认即可
mintpy.save.hdfEos5         = auto  #[yes / no], auto for no, save time-series to HDF-EOS5 format
mintpy.save.hdfEos5.update  = auto  #[yes / no], auto for no, put XXXXXXXX as endDate in output filename
mintpy.save.hdfEos5.subset  = auto  #[yes / no], auto for no, put subset range info   in output filename

##-------------------------------------------------- 13-4.自动绘图 ------------------------------------------------------------##
mintpy.plot           = yes  #[yes / no], auto for yes, plot files generated by default processing to pic folder
mintpy.plot.dpi       = 150  #[int], auto for 150, number of dots per inch (DPI)
mintpy.plot.maxMemory = 4    #[float], auto for 4, max memory used by one call of view.py for plotting.
##-----------------------------------------------------------------------------------------------------------------------------##



##-------------------------------------------------- 后处理：MintPy一些实用的脚本与操作 -------------------------------------------------------##
## 更多相关说明与教程可参考以下三个网站：
## https://github.com/insarlab/MintPy
## https://github.com/insarlab/MintPy-tutorial
## https://mintpy.readthedocs.io/en/latest/
## 比较常用的脚本如下所示：
## 1)info.py       # 查看.h5文件内部存储的信息，eg. info.py geo_velocity.h5
## 2)view.py       # 对于非时间序列的结果进行可视化操作，eg. view.py velocity.h5
## 3)tsview.py     # 对时间序列结果进行交互式的可视化操作，点击某个点可具体查看该点形变的时间序列，eg. tsview.py timeseries.h5
## 4)save_gdal.py  # 将.h5文件转化为.tiff文件，便于放入QGIS中制图
## 5)geocode.py    # 将雷达坐标系下的.h5文件转换至地理坐标系下
## QGIS中有一个插件能和MintPy无缝衔接使用，名为"PS Time Series Viewer"，可参考以下视频：
## https://www.bilibili.com/video/BV1BPxUeREua/?spm_id_from=333.1387.upload.video_card.click&vd_source=5ac8af1e26ab13a248ca4947b1075d22
##---------------------------------------------------------------------------------------------------------------------------------------------##
